---
import type { GetStaticPaths } from "astro";
import { getCollection, getEntry } from "astro:content";

export const prerender = true;
export const getStaticPaths = (async () => {
	const recipes = await getCollection("recipes");

	return recipes.map((recipe) => ({
		params: { id: recipe.id },
		props: { ...recipe.data },
	}));
}) satisfies GetStaticPaths;

import BaseLayout from "../../layouts/BaseLayout.astro";
import { Picture } from "astro:assets";
const recipe = await getEntry("recipes", Astro.params.id);
const { title, image, imageAlt, ingredients, steps } = Astro.props;
const stepGroupName = `recipe-step-${Astro.params.id}`;
---

<BaseLayout title={title} description={`Rezept f√ºr ${title}`}>
	<main>
		<button class="wake-lock-button" aria-label="Bildschirm wach halten" title="Bildschirm wach halten">
			<span class="icon-off">‚òÄÔ∏è</span>
			<span class="icon-on">üîÜ</span>
		</button>
		<a href="/">
			<h1 transition:name={`recipe-title-${Astro.params.id}`}>{title}</h1>
		</a>
		<h2 id="ingredients-heading">Zutaten</h2>
		<ul class="ingredients" aria-labelledby="ingredients-heading">
			{
				ingredients.map((ingredient, index) => (
					<li>
						<input type="checkbox" id={"i" + index} title={ingredient + " hinzugef√ºgt"} />
						<label for={"i" + index}>{ingredient}</label>
					</li>
				))
			}
		</ul>
		<input type="radio" id="step-reset" name={stepGroupName} class="step-reset" checked />
		<h2 id="steps-heading"><label for="step-reset">Zubereitung</label></h2>
		<ol class="steps" aria-labelledby="steps-heading">
			{steps.map((step, index) => (
					<li>
						<input type="radio" id={`step-${index}`} name={stepGroupName} />
						<label for={`step-${index}`}>{step}</label>
					</li>
				))}
		</ol>
		{recipe?.rendered?.html && <section set:html={recipe?.rendered?.html} />}
		{image && <Picture 
								width=500 
								src={image}
								alt={imageAlt ?? ""}
								formats={["webp", "jpg"]}
								transition:name={`recipe-image-${Astro.params.id}`}
							 />}
		
	</main>
</BaseLayout>

<style>
	main {
		position: relative;
		display: flex;
		flex-direction: column;
		gap: 0.2em;

		max-width: 500px;
		margin-inline: auto;
	}

	main > h2 {
		margin-block-start: 0.2em;
	}

	.step-reset {
		position: absolute;
		opacity: 0;
		pointer-events: none;
	}

	h2 > label {
		cursor: pointer;
		display: block;
	}

	main > a > h1 {
		text-align: center;
		margin-block: 0.1em;
	}

	main > a:has(h1) {
	position: relative;
	cursor: pointer;
	text-decoration: none;
	color: var(--color-text);

		::before {
			content: "‚Üê";
			font-weight: bold;
			position: absolute;
			left: 1em;
			opacity: 0;
			transition: all var(--animation-speed) var(--animation-easing);
		}
		&:hover	{
			::before {
				left: 0;
					opacity: 1;
				}
			}
	}

	.ingredients, .steps, h2, section {
		padding: 0 0.4em;
		margin: 0;

		li {
			margin-block: 0.2em ;
			border-radius: var(--border-radius);
			transition: background var(--animation-speed) var(--animation-easing);
			background-color: var(--color-background);
		}
	}

	.ingredients {
		list-style: none;
		
		li {
			display: flex;
			label {
				padding: 0.4em;
				padding-inline-start: 0;
				flex-grow: 1;
			}
			background: linear-gradient(to right, var(--color-highlight) 50%, var(--color-background) 50%);
			background-size: 201% 100%;
			background-position: right;
			transition: background-position var(--animation-speed) var(--animation-easing);
		}
		li:has(input:checked) {
			background-position: left;
		}

		input {
			margin: 0.4em;
			accent-color: var(--color-highlight-soft);
		}
	}

	.steps {
		list-style: none;
		counter-reset: step;

		li {
			counter-increment: step;
		}
		input {
			position: absolute;
			opacity: 0;
			pointer-events: none;
		}
		label {
			display: block;
			cursor: pointer;
			padding: 0.4em;
		}
		label::before {
			content: counter(step) ". ";
			font-weight: 600;
		}
		li:has(~ li input:checked) {
			background: var(--color-highlight-soft);
		}
		li:has(input:checked) {
			background: var(--color-highlight);
		}
	}

	main>picture {
		display: block;
		
		img {
			display: block;
			width: 100%;
			height: auto;
		}
	}

	.wake-lock-button {
		display: none;
		position: absolute;
		top: 0.1em;
		right: 0;
		z-index: 100;
		padding: 0.5rem;
		border: none;
		border-radius: var(--border-radius);
		background-color: var(--color-background);
		cursor: pointer;
		font-size: 1.5rem;
		line-height: 1;
		transition: transform var(--animation-speed) var(--animation-easing);

		&:hover {
			transform: scale(1.1);
		}

		.icon-on {
			display: none;
		}

		&.active {
			.icon-off {
				display: none;
			}
			.icon-on {
				display: inline;
			}
		}
	}

</style>

<script>
	const wakeLockButton = document.querySelector(".wake-lock-button") as HTMLButtonElement | null;
	let wakeLock: WakeLockSentinel | null = null;

	// Only enable wake lock functionality if the API is supported
	if ("wakeLock" in navigator && wakeLockButton) {
		wakeLockButton.style.display = "block";
		wakeLockButton.addEventListener("click", toggleWakeLock);

		// Re-acquire wake lock when page becomes visible again
		document.addEventListener("visibilitychange", async () => {
			if (wakeLockButton.classList.contains("active") && document.visibilityState === "visible") {
				await requestWakeLock();
			}
		});
	}

	async function toggleWakeLock() {
		if (wakeLock !== null) {
			await wakeLock.release();
			wakeLock = null;
			wakeLockButton?.classList.remove("active");
		} else {
			await requestWakeLock();
		}
	}

	async function requestWakeLock() {
		try {
			wakeLock = await navigator.wakeLock.request("screen");
			wakeLockButton?.classList.add("active");
			wakeLock.addEventListener("release", () => {
				wakeLockButton?.classList.remove("active");
				wakeLock = null;
			});
		} catch (err) {
			console.error("Wake Lock request failed:", err);
		}
	}
</script>
